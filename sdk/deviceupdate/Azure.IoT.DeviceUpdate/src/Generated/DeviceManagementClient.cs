// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.IoT.DeviceUpdate
{
    // Data plane generated client.
    /// <summary> The DeviceManagement service client. </summary>
    public partial class DeviceManagementClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://api.adu.microsoft.com/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _instanceId;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of DeviceManagementClient for mocking. </summary>
        protected DeviceManagementClient()
        {
        }

        /// <summary> Initializes a new instance of DeviceManagementClient. </summary>
        /// <param name="endpoint"> The Device Update for IoT Hub account endpoint (hostname only, no protocol). </param>
        /// <param name="instanceId"> The Device Update for IoT Hub account instance identifier. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/>, <paramref name="instanceId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="instanceId"/> is an empty string, and was expected to be non-empty. </exception>
        public DeviceManagementClient(Uri endpoint, string instanceId, TokenCredential credential) : this(endpoint, instanceId, credential, new DeviceUpdateClientOptions())
        {
        }

        /// <summary> Initializes a new instance of DeviceManagementClient. </summary>
        /// <param name="endpoint"> The Device Update for IoT Hub account endpoint (hostname only, no protocol). </param>
        /// <param name="instanceId"> The Device Update for IoT Hub account instance identifier. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/>, <paramref name="instanceId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="instanceId"/> is an empty string, and was expected to be non-empty. </exception>
        public DeviceManagementClient(Uri endpoint, string instanceId, TokenCredential credential, DeviceUpdateClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            Argument.AssertNotNullOrEmpty(instanceId, nameof(instanceId));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new DeviceUpdateClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential, AuthorizationScopes) }, new ResponseClassifier());
            _endpoint = endpoint;
            _instanceId = instanceId;
            _apiVersion = options.Version;
        }

        /// <summary> Gets the properties of a device class. </summary>
        /// <param name="deviceClassId">
        /// The device class identifier. This is generated from the model Id and the compat
        /// properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClassAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<DeviceClass>> GetDeviceClassAsync(string deviceClassId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDeviceClassAsync(deviceClassId, context).ConfigureAwait(false);
            return Response.FromValue(DeviceClass.FromResponse(response), response);
        }

        /// <summary> Gets the properties of a device class. </summary>
        /// <param name="deviceClassId">
        /// The device class identifier. This is generated from the model Id and the compat
        /// properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClass(string,CancellationToken)']/*" />
        public virtual Response<DeviceClass> GetDeviceClass(string deviceClassId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDeviceClass(deviceClassId, context);
            return Response.FromValue(DeviceClass.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets the properties of a device class.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeviceClassAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="deviceClassId">
        /// The device class identifier. This is generated from the model Id and the compat
        /// properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClassAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetDeviceClassAsync(string deviceClassId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassRequest(deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets the properties of a device class.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeviceClass(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="deviceClassId">
        /// The device class identifier. This is generated from the model Id and the compat
        /// properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClass(string,RequestContext)']/*" />
        public virtual Response GetDeviceClass(string deviceClassId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassRequest(deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update device class details.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="deviceClassId">
        /// The device class identifier. This is generated from the model Id and the compat
        /// properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='UpdateDeviceClassAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateDeviceClassAsync(string deviceClassId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.UpdateDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateDeviceClassRequest(deviceClassId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update device class details.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="deviceClassId">
        /// The device class identifier. This is generated from the model Id and the compat
        /// properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='UpdateDeviceClass(string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateDeviceClass(string deviceClassId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.UpdateDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateDeviceClassRequest(deviceClassId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a device class. Device classes are created automatically when Device
        /// Update-enabled devices are connected to the hub but are not automatically
        /// cleaned up since they are referenced by DeviceClassSubgroups. If the user has
        /// deleted all DeviceClassSubgroups for a device class they can also delete the
        /// device class to remove the records from the system and to stop checking the
        /// compatibility of this device class with new updates. If a device is ever
        /// reconnected for this device class it will be re-created.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="deviceClassId">
        /// The device class identifier. This is generated from the model Id and the compat
        /// properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='DeleteDeviceClassAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteDeviceClassAsync(string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeviceClassRequest(deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a device class. Device classes are created automatically when Device
        /// Update-enabled devices are connected to the hub but are not automatically
        /// cleaned up since they are referenced by DeviceClassSubgroups. If the user has
        /// deleted all DeviceClassSubgroups for a device class they can also delete the
        /// device class to remove the records from the system and to stop checking the
        /// compatibility of this device class with new updates. If a device is ever
        /// reconnected for this device class it will be re-created.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="deviceClassId">
        /// The device class identifier. This is generated from the model Id and the compat
        /// properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='DeleteDeviceClass(string,RequestContext)']/*" />
        public virtual Response DeleteDeviceClass(string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeviceClassRequest(deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Gets the device properties and latest deployment status for a device connected
        /// to Device Update for IoT Hub.
        /// </summary>
        /// <param name="deviceId"> Device identity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<Device>> GetDeviceAsync(string deviceId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(deviceId, nameof(deviceId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDeviceAsync(deviceId, context).ConfigureAwait(false);
            return Response.FromValue(Device.FromResponse(response), response);
        }

        /// <summary>
        /// Gets the device properties and latest deployment status for a device connected
        /// to Device Update for IoT Hub.
        /// </summary>
        /// <param name="deviceId"> Device identity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDevice(string,CancellationToken)']/*" />
        public virtual Response<Device> GetDevice(string deviceId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(deviceId, nameof(deviceId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDevice(deviceId, context);
            return Response.FromValue(Device.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets the device properties and latest deployment status for a device connected
        /// to Device Update for IoT Hub.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeviceAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="deviceId"> Device identity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetDeviceAsync(string deviceId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(deviceId, nameof(deviceId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDevice");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceRequest(deviceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets the device properties and latest deployment status for a device connected
        /// to Device Update for IoT Hub.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDevice(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="deviceId"> Device identity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDevice(string,RequestContext)']/*" />
        public virtual Response GetDevice(string deviceId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(deviceId, nameof(deviceId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDevice");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceRequest(deviceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Gets the device module properties and latest deployment status for a device
        /// module connected to Device Update for IoT Hub.
        /// </summary>
        /// <param name="deviceId"> Device identifier in Azure IoT Hub. </param>
        /// <param name="moduleId"> Device module identifier in Azure IoT Hub. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> or <paramref name="moduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceId"/> or <paramref name="moduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceModuleAsync(string,string,CancellationToken)']/*" />
        public virtual async Task<Response<Device>> GetDeviceModuleAsync(string deviceId, string moduleId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(deviceId, nameof(deviceId));
            Argument.AssertNotNullOrEmpty(moduleId, nameof(moduleId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDeviceModuleAsync(deviceId, moduleId, context).ConfigureAwait(false);
            return Response.FromValue(Device.FromResponse(response), response);
        }

        /// <summary>
        /// Gets the device module properties and latest deployment status for a device
        /// module connected to Device Update for IoT Hub.
        /// </summary>
        /// <param name="deviceId"> Device identifier in Azure IoT Hub. </param>
        /// <param name="moduleId"> Device module identifier in Azure IoT Hub. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> or <paramref name="moduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceId"/> or <paramref name="moduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceModule(string,string,CancellationToken)']/*" />
        public virtual Response<Device> GetDeviceModule(string deviceId, string moduleId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(deviceId, nameof(deviceId));
            Argument.AssertNotNullOrEmpty(moduleId, nameof(moduleId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDeviceModule(deviceId, moduleId, context);
            return Response.FromValue(Device.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets the device module properties and latest deployment status for a device
        /// module connected to Device Update for IoT Hub.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeviceModuleAsync(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="deviceId"> Device identifier in Azure IoT Hub. </param>
        /// <param name="moduleId"> Device module identifier in Azure IoT Hub. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> or <paramref name="moduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceId"/> or <paramref name="moduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceModuleAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetDeviceModuleAsync(string deviceId, string moduleId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(deviceId, nameof(deviceId));
            Argument.AssertNotNullOrEmpty(moduleId, nameof(moduleId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceModule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceModuleRequest(deviceId, moduleId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets the device module properties and latest deployment status for a device
        /// module connected to Device Update for IoT Hub.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeviceModule(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="deviceId"> Device identifier in Azure IoT Hub. </param>
        /// <param name="moduleId"> Device module identifier in Azure IoT Hub. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> or <paramref name="moduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceId"/> or <paramref name="moduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceModule(string,string,RequestContext)']/*" />
        public virtual Response GetDeviceModule(string deviceId, string moduleId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(deviceId, nameof(deviceId));
            Argument.AssertNotNullOrEmpty(moduleId, nameof(moduleId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceModule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceModuleRequest(deviceId, moduleId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Gets the breakdown of how many devices are on their latest update, have new
        /// updates available, or are in progress receiving new updates.
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetUpdateComplianceAsync(CancellationToken)']/*" />
        public virtual async Task<Response<UpdateCompliance>> GetUpdateComplianceAsync(CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetUpdateComplianceAsync(context).ConfigureAwait(false);
            return Response.FromValue(UpdateCompliance.FromResponse(response), response);
        }

        /// <summary>
        /// Gets the breakdown of how many devices are on their latest update, have new
        /// updates available, or are in progress receiving new updates.
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetUpdateCompliance(CancellationToken)']/*" />
        public virtual Response<UpdateCompliance> GetUpdateCompliance(CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetUpdateCompliance(context);
            return Response.FromValue(UpdateCompliance.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets the breakdown of how many devices are on their latest update, have new
        /// updates available, or are in progress receiving new updates.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetUpdateComplianceAsync(CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetUpdateComplianceAsync(RequestContext)']/*" />
        public virtual async Task<Response> GetUpdateComplianceAsync(RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetUpdateCompliance");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUpdateComplianceRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets the breakdown of how many devices are on their latest update, have new
        /// updates available, or are in progress receiving new updates.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetUpdateCompliance(CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetUpdateCompliance(RequestContext)']/*" />
        public virtual Response GetUpdateCompliance(RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetUpdateCompliance");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUpdateComplianceRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the device group properties. </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetGroupAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<Group>> GetGroupAsync(string groupId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetGroupAsync(groupId, context).ConfigureAwait(false);
            return Response.FromValue(Group.FromResponse(response), response);
        }

        /// <summary> Gets the device group properties. </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetGroup(string,CancellationToken)']/*" />
        public virtual Response<Group> GetGroup(string groupId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetGroup(groupId, context);
            return Response.FromValue(Group.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets the device group properties.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetGroupAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetGroupAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetGroupAsync(string groupId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGroupRequest(groupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets the device group properties.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetGroup(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetGroup(string,RequestContext)']/*" />
        public virtual Response GetGroup(string groupId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGroupRequest(groupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a device group. This group is automatically created when a Device
        /// Update-enabled device is connected to the hub and reports its properties.
        /// Groups, subgroups, and deployments are not automatically cleaned up but are
        /// retained for history purposes. Users can call this method to delete a group if
        /// they do not need to retain any of the history of the group and no longer need
        /// it. If a device is ever connected again for this group after the group was
        /// deleted it will be automatically re-created but there will be no history.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='DeleteGroupAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteGroupAsync(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteGroupRequest(groupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a device group. This group is automatically created when a Device
        /// Update-enabled device is connected to the hub and reports its properties.
        /// Groups, subgroups, and deployments are not automatically cleaned up but are
        /// retained for history purposes. Users can call this method to delete a group if
        /// they do not need to retain any of the history of the group and no longer need
        /// it. If a device is ever connected again for this group after the group was
        /// deleted it will be automatically re-created but there will be no history.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='DeleteGroup(string,RequestContext)']/*" />
        public virtual Response DeleteGroup(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteGroupRequest(groupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get device group update compliance information such as how many devices are on
        /// their latest update, how many need new updates, and how many are in progress on
        /// receiving a new update.
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetUpdateComplianceForGroupAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<UpdateCompliance>> GetUpdateComplianceForGroupAsync(string groupId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetUpdateComplianceForGroupAsync(groupId, context).ConfigureAwait(false);
            return Response.FromValue(UpdateCompliance.FromResponse(response), response);
        }

        /// <summary>
        /// Get device group update compliance information such as how many devices are on
        /// their latest update, how many need new updates, and how many are in progress on
        /// receiving a new update.
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetUpdateComplianceForGroup(string,CancellationToken)']/*" />
        public virtual Response<UpdateCompliance> GetUpdateComplianceForGroup(string groupId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetUpdateComplianceForGroup(groupId, context);
            return Response.FromValue(UpdateCompliance.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Get device group update compliance information such as how many devices are on
        /// their latest update, how many need new updates, and how many are in progress on
        /// receiving a new update.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetUpdateComplianceForGroupAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetUpdateComplianceForGroupAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetUpdateComplianceForGroupAsync(string groupId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetUpdateComplianceForGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUpdateComplianceForGroupRequest(groupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get device group update compliance information such as how many devices are on
        /// their latest update, how many need new updates, and how many are in progress on
        /// receiving a new update.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetUpdateComplianceForGroup(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetUpdateComplianceForGroup(string,RequestContext)']/*" />
        public virtual Response GetUpdateComplianceForGroup(string groupId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetUpdateComplianceForGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUpdateComplianceForGroupRequest(groupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the deployment properties. </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeploymentAsync(string,string,CancellationToken)']/*" />
        public virtual async Task<Response<Deployment>> GetDeploymentAsync(string groupId, string deploymentId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDeploymentAsync(groupId, deploymentId, context).ConfigureAwait(false);
            return Response.FromValue(Deployment.FromResponse(response), response);
        }

        /// <summary> Gets the deployment properties. </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeployment(string,string,CancellationToken)']/*" />
        public virtual Response<Deployment> GetDeployment(string groupId, string deploymentId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDeployment(groupId, deploymentId, context);
            return Response.FromValue(Deployment.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets the deployment properties.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeploymentAsync(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeploymentAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetDeploymentAsync(string groupId, string deploymentId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentRequest(groupId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets the deployment properties.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeployment(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeployment(string,string,RequestContext)']/*" />
        public virtual Response GetDeployment(string groupId, string deploymentId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentRequest(groupId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates or updates a deployment. </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="resource"> Deployment details. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deploymentId"/> or <paramref name="resource"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='CreateOrUpdateDeploymentAsync(string,string,Deployment,CancellationToken)']/*" />
        public virtual async Task<Response<Deployment>> CreateOrUpdateDeploymentAsync(string groupId, string deploymentId, Deployment resource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));
            Argument.AssertNotNull(resource, nameof(resource));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Response response = await CreateOrUpdateDeploymentAsync(groupId, deploymentId, content, context).ConfigureAwait(false);
            return Response.FromValue(Deployment.FromResponse(response), response);
        }

        /// <summary> Creates or updates a deployment. </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="resource"> Deployment details. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deploymentId"/> or <paramref name="resource"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='CreateOrUpdateDeployment(string,string,Deployment,CancellationToken)']/*" />
        public virtual Response<Deployment> CreateOrUpdateDeployment(string groupId, string deploymentId, Deployment resource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));
            Argument.AssertNotNull(resource, nameof(resource));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Response response = CreateOrUpdateDeployment(groupId, deploymentId, content, context);
            return Response.FromValue(Deployment.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Creates or updates a deployment.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateOrUpdateDeploymentAsync(string,string,Deployment,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deploymentId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='CreateOrUpdateDeploymentAsync(string,string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreateOrUpdateDeploymentAsync(string groupId, string deploymentId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.CreateOrUpdateDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateDeploymentRequest(groupId, deploymentId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates or updates a deployment.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateOrUpdateDeployment(string,string,Deployment,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deploymentId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='CreateOrUpdateDeployment(string,string,RequestContent,RequestContext)']/*" />
        public virtual Response CreateOrUpdateDeployment(string groupId, string deploymentId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.CreateOrUpdateDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateDeploymentRequest(groupId, deploymentId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a deployment.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='DeleteDeploymentAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteDeploymentAsync(string groupId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentRequest(groupId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a deployment.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='DeleteDeployment(string,string,RequestContext)']/*" />
        public virtual Response DeleteDeployment(string groupId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentRequest(groupId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Gets the status of a deployment including a breakdown of how many devices in
        /// the deployment are in progress, completed, or failed.
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeploymentStatusAsync(string,string,CancellationToken)']/*" />
        public virtual async Task<Response<DeploymentStatus>> GetDeploymentStatusAsync(string groupId, string deploymentId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDeploymentStatusAsync(groupId, deploymentId, context).ConfigureAwait(false);
            return Response.FromValue(DeploymentStatus.FromResponse(response), response);
        }

        /// <summary>
        /// Gets the status of a deployment including a breakdown of how many devices in
        /// the deployment are in progress, completed, or failed.
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeploymentStatus(string,string,CancellationToken)']/*" />
        public virtual Response<DeploymentStatus> GetDeploymentStatus(string groupId, string deploymentId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDeploymentStatus(groupId, deploymentId, context);
            return Response.FromValue(DeploymentStatus.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets the status of a deployment including a breakdown of how many devices in
        /// the deployment are in progress, completed, or failed.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeploymentStatusAsync(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeploymentStatusAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetDeploymentStatusAsync(string groupId, string deploymentId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeploymentStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentStatusRequest(groupId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets the status of a deployment including a breakdown of how many devices in
        /// the deployment are in progress, completed, or failed.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeploymentStatus(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeploymentStatus(string,string,RequestContext)']/*" />
        public virtual Response GetDeploymentStatus(string groupId, string deploymentId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeploymentStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentStatusRequest(groupId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Gets device class subgroup details. A device class subgroup is the set of
        /// devices within the group that share the same device class. All devices within
        /// the same device class are compatible with the same updates.
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClassSubgroupAsync(string,string,CancellationToken)']/*" />
        public virtual async Task<Response<DeviceClassSubgroup>> GetDeviceClassSubgroupAsync(string groupId, string deviceClassId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDeviceClassSubgroupAsync(groupId, deviceClassId, context).ConfigureAwait(false);
            return Response.FromValue(DeviceClassSubgroup.FromResponse(response), response);
        }

        /// <summary>
        /// Gets device class subgroup details. A device class subgroup is the set of
        /// devices within the group that share the same device class. All devices within
        /// the same device class are compatible with the same updates.
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClassSubgroup(string,string,CancellationToken)']/*" />
        public virtual Response<DeviceClassSubgroup> GetDeviceClassSubgroup(string groupId, string deviceClassId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDeviceClassSubgroup(groupId, deviceClassId, context);
            return Response.FromValue(DeviceClassSubgroup.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets device class subgroup details. A device class subgroup is the set of
        /// devices within the group that share the same device class. All devices within
        /// the same device class are compatible with the same updates.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeviceClassSubgroupAsync(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClassSubgroupAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetDeviceClassSubgroupAsync(string groupId, string deviceClassId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets device class subgroup details. A device class subgroup is the set of
        /// devices within the group that share the same device class. All devices within
        /// the same device class are compatible with the same updates.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeviceClassSubgroup(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClassSubgroup(string,string,RequestContext)']/*" />
        public virtual Response GetDeviceClassSubgroup(string groupId, string deviceClassId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a device class subgroup. This subgroup is automatically created when a
        /// Device Update-enabled device is connected to the hub and reports its
        /// properties. Groups, subgroups, and deployments are not automatically cleaned up
        /// but are retained for history purposes. Users can call this method to delete a
        /// subgroup if they do not need to retain any of the history of the subgroup and
        /// no longer need it. If a device is ever connected again for this subgroup after
        /// the subgroup was deleted it will be automatically re-created but there will be
        /// no history.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='DeleteDeviceClassSubgroupAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteDeviceClassSubgroupAsync(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a device class subgroup. This subgroup is automatically created when a
        /// Device Update-enabled device is connected to the hub and reports its
        /// properties. Groups, subgroups, and deployments are not automatically cleaned up
        /// but are retained for history purposes. Users can call this method to delete a
        /// subgroup if they do not need to retain any of the history of the subgroup and
        /// no longer need it. If a device is ever connected again for this subgroup after
        /// the subgroup was deleted it will be automatically re-created but there will be
        /// no history.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='DeleteDeviceClassSubgroup(string,string,RequestContext)']/*" />
        public virtual Response DeleteDeviceClassSubgroup(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get device class subgroup update compliance information such as how many
        /// devices are on their latest update, how many need new updates, and how many are
        /// in progress on receiving a new update.
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClassSubgroupUpdateComplianceAsync(string,string,CancellationToken)']/*" />
        public virtual async Task<Response<UpdateCompliance>> GetDeviceClassSubgroupUpdateComplianceAsync(string groupId, string deviceClassId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDeviceClassSubgroupUpdateComplianceAsync(groupId, deviceClassId, context).ConfigureAwait(false);
            return Response.FromValue(UpdateCompliance.FromResponse(response), response);
        }

        /// <summary>
        /// Get device class subgroup update compliance information such as how many
        /// devices are on their latest update, how many need new updates, and how many are
        /// in progress on receiving a new update.
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClassSubgroupUpdateCompliance(string,string,CancellationToken)']/*" />
        public virtual Response<UpdateCompliance> GetDeviceClassSubgroupUpdateCompliance(string groupId, string deviceClassId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDeviceClassSubgroupUpdateCompliance(groupId, deviceClassId, context);
            return Response.FromValue(UpdateCompliance.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Get device class subgroup update compliance information such as how many
        /// devices are on their latest update, how many need new updates, and how many are
        /// in progress on receiving a new update.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeviceClassSubgroupUpdateComplianceAsync(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClassSubgroupUpdateComplianceAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetDeviceClassSubgroupUpdateComplianceAsync(string groupId, string deviceClassId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroupUpdateCompliance");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupUpdateComplianceRequest(groupId, deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get device class subgroup update compliance information such as how many
        /// devices are on their latest update, how many need new updates, and how many are
        /// in progress on receiving a new update.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeviceClassSubgroupUpdateCompliance(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClassSubgroupUpdateCompliance(string,string,RequestContext)']/*" />
        public virtual Response GetDeviceClassSubgroupUpdateCompliance(string groupId, string deviceClassId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroupUpdateCompliance");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupUpdateComplianceRequest(groupId, deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get the best available update for a device class subgroup and a count of how
        /// many devices need this update.
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetBestUpdatesForDeviceClassSubgroupAsync(string,string,CancellationToken)']/*" />
        public virtual async Task<Response<DeviceClassSubgroupUpdatableDevices>> GetBestUpdatesForDeviceClassSubgroupAsync(string groupId, string deviceClassId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetBestUpdatesForDeviceClassSubgroupAsync(groupId, deviceClassId, context).ConfigureAwait(false);
            return Response.FromValue(DeviceClassSubgroupUpdatableDevices.FromResponse(response), response);
        }

        /// <summary>
        /// Get the best available update for a device class subgroup and a count of how
        /// many devices need this update.
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetBestUpdatesForDeviceClassSubgroup(string,string,CancellationToken)']/*" />
        public virtual Response<DeviceClassSubgroupUpdatableDevices> GetBestUpdatesForDeviceClassSubgroup(string groupId, string deviceClassId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetBestUpdatesForDeviceClassSubgroup(groupId, deviceClassId, context);
            return Response.FromValue(DeviceClassSubgroupUpdatableDevices.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Get the best available update for a device class subgroup and a count of how
        /// many devices need this update.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetBestUpdatesForDeviceClassSubgroupAsync(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetBestUpdatesForDeviceClassSubgroupAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetBestUpdatesForDeviceClassSubgroupAsync(string groupId, string deviceClassId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetBestUpdatesForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetBestUpdatesForDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get the best available update for a device class subgroup and a count of how
        /// many devices need this update.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetBestUpdatesForDeviceClassSubgroup(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetBestUpdatesForDeviceClassSubgroup(string,string,RequestContext)']/*" />
        public virtual Response GetBestUpdatesForDeviceClassSubgroup(string groupId, string deviceClassId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetBestUpdatesForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetBestUpdatesForDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the deployment properties. </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeploymentForDeviceClassSubgroupAsync(string,string,string,CancellationToken)']/*" />
        public virtual async Task<Response<DeviceClassSubgroupDeployment>> GetDeploymentForDeviceClassSubgroupAsync(string groupId, string deviceClassId, string deploymentId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDeploymentForDeviceClassSubgroupAsync(groupId, deviceClassId, deploymentId, context).ConfigureAwait(false);
            return Response.FromValue(DeviceClassSubgroupDeployment.FromResponse(response), response);
        }

        /// <summary> Gets the deployment properties. </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeploymentForDeviceClassSubgroup(string,string,string,CancellationToken)']/*" />
        public virtual Response<DeviceClassSubgroupDeployment> GetDeploymentForDeviceClassSubgroup(string groupId, string deviceClassId, string deploymentId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDeploymentForDeviceClassSubgroup(groupId, deviceClassId, deploymentId, context);
            return Response.FromValue(DeviceClassSubgroupDeployment.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets the deployment properties.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeploymentForDeviceClassSubgroupAsync(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeploymentForDeviceClassSubgroupAsync(string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetDeploymentForDeviceClassSubgroupAsync(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeploymentForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentForDeviceClassSubgroupRequest(groupId, deviceClassId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets the deployment properties.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeploymentForDeviceClassSubgroup(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeploymentForDeviceClassSubgroup(string,string,string,RequestContext)']/*" />
        public virtual Response GetDeploymentForDeviceClassSubgroup(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeploymentForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentForDeviceClassSubgroupRequest(groupId, deviceClassId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a device class subgroup deployment.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='DeleteDeploymentForDeviceClassSubgroupAsync(string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteDeploymentForDeviceClassSubgroupAsync(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeploymentForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentForDeviceClassSubgroupRequest(groupId, deviceClassId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a device class subgroup deployment.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='DeleteDeploymentForDeviceClassSubgroup(string,string,string,RequestContext)']/*" />
        public virtual Response DeleteDeploymentForDeviceClassSubgroup(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeploymentForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentForDeviceClassSubgroupRequest(groupId, deviceClassId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Stops a deployment. </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='StopDeploymentAsync(string,string,string,CancellationToken)']/*" />
        public virtual async Task<Response<DeviceClassSubgroupDeployment>> StopDeploymentAsync(string groupId, string deviceClassId, string deploymentId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await StopDeploymentAsync(groupId, deviceClassId, deploymentId, context).ConfigureAwait(false);
            return Response.FromValue(DeviceClassSubgroupDeployment.FromResponse(response), response);
        }

        /// <summary> Stops a deployment. </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='StopDeployment(string,string,string,CancellationToken)']/*" />
        public virtual Response<DeviceClassSubgroupDeployment> StopDeployment(string groupId, string deviceClassId, string deploymentId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = StopDeployment(groupId, deviceClassId, deploymentId, context);
            return Response.FromValue(DeviceClassSubgroupDeployment.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Stops a deployment.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="StopDeploymentAsync(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='StopDeploymentAsync(string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> StopDeploymentAsync(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.StopDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStopDeploymentRequest(groupId, deviceClassId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Stops a deployment.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="StopDeployment(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='StopDeployment(string,string,string,RequestContext)']/*" />
        public virtual Response StopDeployment(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.StopDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStopDeploymentRequest(groupId, deviceClassId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retries a deployment with failed devices. </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='RetryDeploymentAsync(string,string,string,CancellationToken)']/*" />
        public virtual async Task<Response<DeviceClassSubgroupDeployment>> RetryDeploymentAsync(string groupId, string deviceClassId, string deploymentId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await RetryDeploymentAsync(groupId, deviceClassId, deploymentId, context).ConfigureAwait(false);
            return Response.FromValue(DeviceClassSubgroupDeployment.FromResponse(response), response);
        }

        /// <summary> Retries a deployment with failed devices. </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='RetryDeployment(string,string,string,CancellationToken)']/*" />
        public virtual Response<DeviceClassSubgroupDeployment> RetryDeployment(string groupId, string deviceClassId, string deploymentId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = RetryDeployment(groupId, deviceClassId, deploymentId, context);
            return Response.FromValue(DeviceClassSubgroupDeployment.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retries a deployment with failed devices.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RetryDeploymentAsync(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='RetryDeploymentAsync(string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> RetryDeploymentAsync(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.RetryDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRetryDeploymentRequest(groupId, deviceClassId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retries a deployment with failed devices.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RetryDeployment(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='RetryDeployment(string,string,string,RequestContext)']/*" />
        public virtual Response RetryDeployment(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.RetryDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRetryDeploymentRequest(groupId, deviceClassId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Gets the status of a deployment including a breakdown of how many devices in
        /// the deployment are in progress, completed, or failed.
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClassSubgroupDeploymentStatusAsync(string,string,string,CancellationToken)']/*" />
        public virtual async Task<Response<DeviceClassSubgroupDeploymentStatus>> GetDeviceClassSubgroupDeploymentStatusAsync(string groupId, string deviceClassId, string deploymentId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDeviceClassSubgroupDeploymentStatusAsync(groupId, deviceClassId, deploymentId, context).ConfigureAwait(false);
            return Response.FromValue(DeviceClassSubgroupDeploymentStatus.FromResponse(response), response);
        }

        /// <summary>
        /// Gets the status of a deployment including a breakdown of how many devices in
        /// the deployment are in progress, completed, or failed.
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClassSubgroupDeploymentStatus(string,string,string,CancellationToken)']/*" />
        public virtual Response<DeviceClassSubgroupDeploymentStatus> GetDeviceClassSubgroupDeploymentStatus(string groupId, string deviceClassId, string deploymentId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDeviceClassSubgroupDeploymentStatus(groupId, deviceClassId, deploymentId, context);
            return Response.FromValue(DeviceClassSubgroupDeploymentStatus.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets the status of a deployment including a breakdown of how many devices in
        /// the deployment are in progress, completed, or failed.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeviceClassSubgroupDeploymentStatusAsync(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClassSubgroupDeploymentStatusAsync(string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetDeviceClassSubgroupDeploymentStatusAsync(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroupDeploymentStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupDeploymentStatusRequest(groupId, deviceClassId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets the status of a deployment including a breakdown of how many devices in
        /// the deployment are in progress, completed, or failed.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeviceClassSubgroupDeploymentStatus(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClassSubgroupDeploymentStatus(string,string,string,RequestContext)']/*" />
        public virtual Response GetDeviceClassSubgroupDeploymentStatus(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroupDeploymentStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupDeploymentStatusRequest(groupId, deviceClassId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the device diagnostics log collection. </summary>
        /// <param name="operationId"> The log collection id. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetLogCollectionAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<LogCollection>> GetLogCollectionAsync(string operationId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLogCollectionAsync(operationId, context).ConfigureAwait(false);
            return Response.FromValue(LogCollection.FromResponse(response), response);
        }

        /// <summary> Get the device diagnostics log collection. </summary>
        /// <param name="operationId"> The log collection id. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetLogCollection(string,CancellationToken)']/*" />
        public virtual Response<LogCollection> GetLogCollection(string operationId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLogCollection(operationId, context);
            return Response.FromValue(LogCollection.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Get the device diagnostics log collection
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLogCollectionAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="operationId"> The log collection id. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetLogCollectionAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetLogCollectionAsync(string operationId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetLogCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLogCollectionRequest(operationId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get the device diagnostics log collection
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLogCollection(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="operationId"> The log collection id. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetLogCollection(string,RequestContext)']/*" />
        public virtual Response GetLogCollection(string operationId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetLogCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLogCollectionRequest(operationId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Start the device diagnostics log collection on specified devices. </summary>
        /// <param name="operationId"> The log collection id. </param>
        /// <param name="resource"> Log collection details. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> or <paramref name="resource"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='StartLogCollectionAsync(string,LogCollection,CancellationToken)']/*" />
        public virtual async Task<Response<LogCollection>> StartLogCollectionAsync(string operationId, LogCollection resource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));
            Argument.AssertNotNull(resource, nameof(resource));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Response response = await StartLogCollectionAsync(operationId, content, context).ConfigureAwait(false);
            return Response.FromValue(LogCollection.FromResponse(response), response);
        }

        /// <summary> Start the device diagnostics log collection on specified devices. </summary>
        /// <param name="operationId"> The log collection id. </param>
        /// <param name="resource"> Log collection details. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> or <paramref name="resource"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='StartLogCollection(string,LogCollection,CancellationToken)']/*" />
        public virtual Response<LogCollection> StartLogCollection(string operationId, LogCollection resource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));
            Argument.AssertNotNull(resource, nameof(resource));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Response response = StartLogCollection(operationId, content, context);
            return Response.FromValue(LogCollection.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Start the device diagnostics log collection on specified devices.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="StartLogCollectionAsync(string,LogCollection,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="operationId"> The log collection id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='StartLogCollectionAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> StartLogCollectionAsync(string operationId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.StartLogCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStartLogCollectionRequest(operationId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Start the device diagnostics log collection on specified devices.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="StartLogCollection(string,LogCollection,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="operationId"> The log collection id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='StartLogCollection(string,RequestContent,RequestContext)']/*" />
        public virtual Response StartLogCollection(string operationId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.StartLogCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStartLogCollectionRequest(operationId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get log collection with detailed status. </summary>
        /// <param name="operationId"> The log collection id. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetLogCollectionDetailedStatusAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<LogCollectionOperationDetailedStatus>> GetLogCollectionDetailedStatusAsync(string operationId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLogCollectionDetailedStatusAsync(operationId, context).ConfigureAwait(false);
            return Response.FromValue(LogCollectionOperationDetailedStatus.FromResponse(response), response);
        }

        /// <summary> Get log collection with detailed status. </summary>
        /// <param name="operationId"> The log collection id. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetLogCollectionDetailedStatus(string,CancellationToken)']/*" />
        public virtual Response<LogCollectionOperationDetailedStatus> GetLogCollectionDetailedStatus(string operationId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLogCollectionDetailedStatus(operationId, context);
            return Response.FromValue(LogCollectionOperationDetailedStatus.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Get log collection with detailed status
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLogCollectionDetailedStatusAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="operationId"> The log collection id. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetLogCollectionDetailedStatusAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetLogCollectionDetailedStatusAsync(string operationId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetLogCollectionDetailedStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLogCollectionDetailedStatusRequest(operationId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get log collection with detailed status
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLogCollectionDetailedStatus(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="operationId"> The log collection id. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetLogCollectionDetailedStatus(string,RequestContext)']/*" />
        public virtual Response GetLogCollectionDetailedStatus(string operationId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetLogCollectionDetailedStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLogCollectionDetailedStatusRequest(operationId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Gets a list of all device classes (sets of devices compatible with the same
        /// updates based on the model Id and compat properties reported in the Device
        /// Update PnP interface in IoT Hub) for all devices connected to Device Update for
        /// IoT Hub.
        /// </summary>
        /// <param name="filter"> Restricts the set of device classes returned. You can filter on friendly name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClassesAsync(string,CancellationToken)']/*" />
        public virtual AsyncPageable<DeviceClass> GetDeviceClassesAsync(string filter = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeviceClassesRequest(filter, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeviceClassesNextPageRequest(nextLink, filter, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, DeviceClass.DeserializeDeviceClass, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDeviceClasses", "value", "nextLink", context);
        }

        /// <summary>
        /// Gets a list of all device classes (sets of devices compatible with the same
        /// updates based on the model Id and compat properties reported in the Device
        /// Update PnP interface in IoT Hub) for all devices connected to Device Update for
        /// IoT Hub.
        /// </summary>
        /// <param name="filter"> Restricts the set of device classes returned. You can filter on friendly name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClasses(string,CancellationToken)']/*" />
        public virtual Pageable<DeviceClass> GetDeviceClasses(string filter = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeviceClassesRequest(filter, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeviceClassesNextPageRequest(nextLink, filter, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, DeviceClass.DeserializeDeviceClass, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDeviceClasses", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Gets a list of all device classes (sets of devices compatible with the same
        /// updates based on the model Id and compat properties reported in the Device
        /// Update PnP interface in IoT Hub) for all devices connected to Device Update for
        /// IoT Hub.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeviceClassesAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="filter"> Restricts the set of device classes returned. You can filter on friendly name. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClassesAsync(string,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetDeviceClassesAsync(string filter, RequestContext context)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeviceClassesRequest(filter, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeviceClassesNextPageRequest(nextLink, filter, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDeviceClasses", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Gets a list of all device classes (sets of devices compatible with the same
        /// updates based on the model Id and compat properties reported in the Device
        /// Update PnP interface in IoT Hub) for all devices connected to Device Update for
        /// IoT Hub.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeviceClasses(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="filter"> Restricts the set of device classes returned. You can filter on friendly name. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClasses(string,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetDeviceClasses(string filter, RequestContext context)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeviceClassesRequest(filter, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeviceClassesNextPageRequest(nextLink, filter, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDeviceClasses", "value", "nextLink", context);
        }

        /// <summary> Gets a list of installable updates for a device class. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetInstallableUpdatesForDeviceClassesAsync(string,CancellationToken)']/*" />
        public virtual AsyncPageable<UpdateInfo> GetInstallableUpdatesForDeviceClassesAsync(string deviceClassId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetInstallableUpdatesForDeviceClassesRequest(deviceClassId, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetInstallableUpdatesForDeviceClassesNextPageRequest(nextLink, deviceClassId, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, UpdateInfo.DeserializeUpdateInfo, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetInstallableUpdatesForDeviceClasses", "value", "nextLink", context);
        }

        /// <summary> Gets a list of installable updates for a device class. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetInstallableUpdatesForDeviceClasses(string,CancellationToken)']/*" />
        public virtual Pageable<UpdateInfo> GetInstallableUpdatesForDeviceClasses(string deviceClassId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetInstallableUpdatesForDeviceClassesRequest(deviceClassId, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetInstallableUpdatesForDeviceClassesNextPageRequest(nextLink, deviceClassId, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, UpdateInfo.DeserializeUpdateInfo, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetInstallableUpdatesForDeviceClasses", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Gets a list of installable updates for a device class.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetInstallableUpdatesForDeviceClassesAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetInstallableUpdatesForDeviceClassesAsync(string,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetInstallableUpdatesForDeviceClassesAsync(string deviceClassId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetInstallableUpdatesForDeviceClassesRequest(deviceClassId, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetInstallableUpdatesForDeviceClassesNextPageRequest(nextLink, deviceClassId, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetInstallableUpdatesForDeviceClasses", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Gets a list of installable updates for a device class.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetInstallableUpdatesForDeviceClasses(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetInstallableUpdatesForDeviceClasses(string,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetInstallableUpdatesForDeviceClasses(string deviceClassId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetInstallableUpdatesForDeviceClassesRequest(deviceClassId, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetInstallableUpdatesForDeviceClassesNextPageRequest(nextLink, deviceClassId, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetInstallableUpdatesForDeviceClasses", "value", "nextLink", context);
        }

        /// <summary> Gets a list of devices connected to Device Update for IoT Hub. </summary>
        /// <param name="filter">
        /// Restricts the set of devices returned. You can filter on GroupId,
        /// DeviceClassId, or GroupId and DeploymentStatus. Use DeploymentStatus eq null to
        /// query for devices with no deployment status (that have never been deployed to).
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDevicesAsync(string,CancellationToken)']/*" />
        public virtual AsyncPageable<Device> GetDevicesAsync(string filter = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDevicesRequest(filter, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDevicesNextPageRequest(nextLink, filter, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, Device.DeserializeDevice, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDevices", "value", "nextLink", context);
        }

        /// <summary> Gets a list of devices connected to Device Update for IoT Hub. </summary>
        /// <param name="filter">
        /// Restricts the set of devices returned. You can filter on GroupId,
        /// DeviceClassId, or GroupId and DeploymentStatus. Use DeploymentStatus eq null to
        /// query for devices with no deployment status (that have never been deployed to).
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDevices(string,CancellationToken)']/*" />
        public virtual Pageable<Device> GetDevices(string filter = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDevicesRequest(filter, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDevicesNextPageRequest(nextLink, filter, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, Device.DeserializeDevice, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDevices", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Gets a list of devices connected to Device Update for IoT Hub.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDevicesAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="filter">
        /// Restricts the set of devices returned. You can filter on GroupId,
        /// DeviceClassId, or GroupId and DeploymentStatus. Use DeploymentStatus eq null to
        /// query for devices with no deployment status (that have never been deployed to).
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDevicesAsync(string,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetDevicesAsync(string filter, RequestContext context)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDevicesRequest(filter, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDevicesNextPageRequest(nextLink, filter, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDevices", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Gets a list of devices connected to Device Update for IoT Hub.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDevices(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="filter">
        /// Restricts the set of devices returned. You can filter on GroupId,
        /// DeviceClassId, or GroupId and DeploymentStatus. Use DeploymentStatus eq null to
        /// query for devices with no deployment status (that have never been deployed to).
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDevices(string,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetDevices(string filter, RequestContext context)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDevicesRequest(filter, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDevicesNextPageRequest(nextLink, filter, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDevices", "value", "nextLink", context);
        }

        /// <summary> Gets a list of all device groups.  The $default group will always be returned first. </summary>
        /// <param name="orderby">
        /// Orders the set of groups returned. You can order by groupId, deviceCount,
        /// createdDate, subgroupsWithNewUpdatesAvailableCount,
        /// subgroupsWithUpdatesInProgressCount, or subgroupsOnLatestUpdateCount.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetGroupsAsync(string,CancellationToken)']/*" />
        public virtual AsyncPageable<Group> GetGroupsAsync(string orderby = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetGroupsRequest(orderby, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetGroupsNextPageRequest(nextLink, orderby, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, Group.DeserializeGroup, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetGroups", "value", "nextLink", context);
        }

        /// <summary> Gets a list of all device groups.  The $default group will always be returned first. </summary>
        /// <param name="orderby">
        /// Orders the set of groups returned. You can order by groupId, deviceCount,
        /// createdDate, subgroupsWithNewUpdatesAvailableCount,
        /// subgroupsWithUpdatesInProgressCount, or subgroupsOnLatestUpdateCount.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetGroups(string,CancellationToken)']/*" />
        public virtual Pageable<Group> GetGroups(string orderby = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetGroupsRequest(orderby, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetGroupsNextPageRequest(nextLink, orderby, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, Group.DeserializeGroup, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetGroups", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Gets a list of all device groups.  The $default group will always be returned first.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetGroupsAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="orderby">
        /// Orders the set of groups returned. You can order by groupId, deviceCount,
        /// createdDate, subgroupsWithNewUpdatesAvailableCount,
        /// subgroupsWithUpdatesInProgressCount, or subgroupsOnLatestUpdateCount.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetGroupsAsync(string,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetGroupsAsync(string orderby, RequestContext context)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetGroupsRequest(orderby, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetGroupsNextPageRequest(nextLink, orderby, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetGroups", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Gets a list of all device groups.  The $default group will always be returned first.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetGroups(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="orderby">
        /// Orders the set of groups returned. You can order by groupId, deviceCount,
        /// createdDate, subgroupsWithNewUpdatesAvailableCount,
        /// subgroupsWithUpdatesInProgressCount, or subgroupsOnLatestUpdateCount.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetGroups(string,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetGroups(string orderby, RequestContext context)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetGroupsRequest(orderby, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetGroupsNextPageRequest(nextLink, orderby, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetGroups", "value", "nextLink", context);
        }

        /// <summary>
        /// Get the best available updates for a device group and a count of how many
        /// devices need each update.
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetBestUpdatesForGroupsAsync(string,CancellationToken)']/*" />
        public virtual AsyncPageable<DeviceClassSubgroupUpdatableDevices> GetBestUpdatesForGroupsAsync(string groupId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetBestUpdatesForGroupsRequest(groupId, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetBestUpdatesForGroupsNextPageRequest(nextLink, groupId, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, DeviceClassSubgroupUpdatableDevices.DeserializeDeviceClassSubgroupUpdatableDevices, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetBestUpdatesForGroups", "value", "nextLink", context);
        }

        /// <summary>
        /// Get the best available updates for a device group and a count of how many
        /// devices need each update.
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetBestUpdatesForGroups(string,CancellationToken)']/*" />
        public virtual Pageable<DeviceClassSubgroupUpdatableDevices> GetBestUpdatesForGroups(string groupId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetBestUpdatesForGroupsRequest(groupId, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetBestUpdatesForGroupsNextPageRequest(nextLink, groupId, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, DeviceClassSubgroupUpdatableDevices.DeserializeDeviceClassSubgroupUpdatableDevices, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetBestUpdatesForGroups", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Get the best available updates for a device group and a count of how many
        /// devices need each update.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetBestUpdatesForGroupsAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetBestUpdatesForGroupsAsync(string,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetBestUpdatesForGroupsAsync(string groupId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetBestUpdatesForGroupsRequest(groupId, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetBestUpdatesForGroupsNextPageRequest(nextLink, groupId, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetBestUpdatesForGroups", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Get the best available updates for a device group and a count of how many
        /// devices need each update.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetBestUpdatesForGroups(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetBestUpdatesForGroups(string,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetBestUpdatesForGroups(string groupId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetBestUpdatesForGroupsRequest(groupId, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetBestUpdatesForGroupsNextPageRequest(nextLink, groupId, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetBestUpdatesForGroups", "value", "nextLink", context);
        }

        /// <summary> Gets a list of deployments for a device group. </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="orderby"> Orders the set of deployments returned. You can order by start date. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeploymentsForGroupsAsync(string,string,CancellationToken)']/*" />
        public virtual AsyncPageable<Deployment> GetDeploymentsForGroupsAsync(string groupId, string orderby = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeploymentsForGroupsRequest(groupId, orderby, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeploymentsForGroupsNextPageRequest(nextLink, groupId, orderby, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, Deployment.DeserializeDeployment, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDeploymentsForGroups", "value", "nextLink", context);
        }

        /// <summary> Gets a list of deployments for a device group. </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="orderby"> Orders the set of deployments returned. You can order by start date. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeploymentsForGroups(string,string,CancellationToken)']/*" />
        public virtual Pageable<Deployment> GetDeploymentsForGroups(string groupId, string orderby = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeploymentsForGroupsRequest(groupId, orderby, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeploymentsForGroupsNextPageRequest(nextLink, groupId, orderby, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, Deployment.DeserializeDeployment, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDeploymentsForGroups", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Gets a list of deployments for a device group.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeploymentsForGroupsAsync(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="orderby"> Orders the set of deployments returned. You can order by start date. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeploymentsForGroupsAsync(string,string,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetDeploymentsForGroupsAsync(string groupId, string orderby, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeploymentsForGroupsRequest(groupId, orderby, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeploymentsForGroupsNextPageRequest(nextLink, groupId, orderby, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDeploymentsForGroups", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Gets a list of deployments for a device group.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeploymentsForGroups(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="orderby"> Orders the set of deployments returned. You can order by start date. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeploymentsForGroups(string,string,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetDeploymentsForGroups(string groupId, string orderby, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeploymentsForGroupsRequest(groupId, orderby, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeploymentsForGroupsNextPageRequest(nextLink, groupId, orderby, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDeploymentsForGroups", "value", "nextLink", context);
        }

        /// <summary>
        /// Get the device class subgroups for the group. A device class subgroup is the
        /// set of devices within the group that share the same device class. All devices
        /// within the same device class are compatible with the same updates.
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="filter">
        /// Restricts the set of device class subgroups returned. You can filter on compat
        /// properties by name and value. (i.e. filter=compatProperties/propertyName1 eq 'value1'
        /// and compatProperties/propertyName2 eq 'value2')
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClassSubgroupsForGroupsAsync(string,string,CancellationToken)']/*" />
        public virtual AsyncPageable<DeviceClassSubgroup> GetDeviceClassSubgroupsForGroupsAsync(string groupId, string filter = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeviceClassSubgroupsForGroupsRequest(groupId, filter, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeviceClassSubgroupsForGroupsNextPageRequest(nextLink, groupId, filter, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, DeviceClassSubgroup.DeserializeDeviceClassSubgroup, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDeviceClassSubgroupsForGroups", "value", "nextLink", context);
        }

        /// <summary>
        /// Get the device class subgroups for the group. A device class subgroup is the
        /// set of devices within the group that share the same device class. All devices
        /// within the same device class are compatible with the same updates.
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="filter">
        /// Restricts the set of device class subgroups returned. You can filter on compat
        /// properties by name and value. (i.e. filter=compatProperties/propertyName1 eq 'value1'
        /// and compatProperties/propertyName2 eq 'value2')
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClassSubgroupsForGroups(string,string,CancellationToken)']/*" />
        public virtual Pageable<DeviceClassSubgroup> GetDeviceClassSubgroupsForGroups(string groupId, string filter = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeviceClassSubgroupsForGroupsRequest(groupId, filter, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeviceClassSubgroupsForGroupsNextPageRequest(nextLink, groupId, filter, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, DeviceClassSubgroup.DeserializeDeviceClassSubgroup, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDeviceClassSubgroupsForGroups", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Get the device class subgroups for the group. A device class subgroup is the
        /// set of devices within the group that share the same device class. All devices
        /// within the same device class are compatible with the same updates.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeviceClassSubgroupsForGroupsAsync(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="filter">
        /// Restricts the set of device class subgroups returned. You can filter on compat
        /// properties by name and value. (i.e. filter=compatProperties/propertyName1 eq 'value1'
        /// and compatProperties/propertyName2 eq 'value2')
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClassSubgroupsForGroupsAsync(string,string,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetDeviceClassSubgroupsForGroupsAsync(string groupId, string filter, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeviceClassSubgroupsForGroupsRequest(groupId, filter, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeviceClassSubgroupsForGroupsNextPageRequest(nextLink, groupId, filter, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDeviceClassSubgroupsForGroups", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Get the device class subgroups for the group. A device class subgroup is the
        /// set of devices within the group that share the same device class. All devices
        /// within the same device class are compatible with the same updates.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeviceClassSubgroupsForGroups(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="filter">
        /// Restricts the set of device class subgroups returned. You can filter on compat
        /// properties by name and value. (i.e. filter=compatProperties/propertyName1 eq 'value1'
        /// and compatProperties/propertyName2 eq 'value2')
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceClassSubgroupsForGroups(string,string,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetDeviceClassSubgroupsForGroups(string groupId, string filter, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeviceClassSubgroupsForGroupsRequest(groupId, filter, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeviceClassSubgroupsForGroupsNextPageRequest(nextLink, groupId, filter, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDeviceClassSubgroupsForGroups", "value", "nextLink", context);
        }

        /// <summary> Gets a list of deployments for a device class subgroup. </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="orderby"> Orders the set of deployments returned. You can order by start date. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeploymentsForDeviceClassSubgroupsAsync(string,string,string,CancellationToken)']/*" />
        public virtual AsyncPageable<DeviceClassSubgroupDeployment> GetDeploymentsForDeviceClassSubgroupsAsync(string groupId, string deviceClassId, string orderby = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeploymentsForDeviceClassSubgroupsRequest(groupId, deviceClassId, orderby, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeploymentsForDeviceClassSubgroupsNextPageRequest(nextLink, groupId, deviceClassId, orderby, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, DeviceClassSubgroupDeployment.DeserializeDeviceClassSubgroupDeployment, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDeploymentsForDeviceClassSubgroups", "value", "nextLink", context);
        }

        /// <summary> Gets a list of deployments for a device class subgroup. </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="orderby"> Orders the set of deployments returned. You can order by start date. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeploymentsForDeviceClassSubgroups(string,string,string,CancellationToken)']/*" />
        public virtual Pageable<DeviceClassSubgroupDeployment> GetDeploymentsForDeviceClassSubgroups(string groupId, string deviceClassId, string orderby = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeploymentsForDeviceClassSubgroupsRequest(groupId, deviceClassId, orderby, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeploymentsForDeviceClassSubgroupsNextPageRequest(nextLink, groupId, deviceClassId, orderby, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, DeviceClassSubgroupDeployment.DeserializeDeviceClassSubgroupDeployment, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDeploymentsForDeviceClassSubgroups", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Gets a list of deployments for a device class subgroup.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeploymentsForDeviceClassSubgroupsAsync(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="orderby"> Orders the set of deployments returned. You can order by start date. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeploymentsForDeviceClassSubgroupsAsync(string,string,string,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetDeploymentsForDeviceClassSubgroupsAsync(string groupId, string deviceClassId, string orderby, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeploymentsForDeviceClassSubgroupsRequest(groupId, deviceClassId, orderby, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeploymentsForDeviceClassSubgroupsNextPageRequest(nextLink, groupId, deviceClassId, orderby, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDeploymentsForDeviceClassSubgroups", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Gets a list of deployments for a device class subgroup.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeploymentsForDeviceClassSubgroups(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="orderby"> Orders the set of deployments returned. You can order by start date. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeploymentsForDeviceClassSubgroups(string,string,string,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetDeploymentsForDeviceClassSubgroups(string groupId, string deviceClassId, string orderby, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeploymentsForDeviceClassSubgroupsRequest(groupId, deviceClassId, orderby, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeploymentsForDeviceClassSubgroupsNextPageRequest(nextLink, groupId, deviceClassId, orderby, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDeploymentsForDeviceClassSubgroups", "value", "nextLink", context);
        }

        /// <summary>
        /// Gets a list of devices in a deployment along with their state. Useful for
        /// getting a list of failed devices.
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="filter">
        /// Restricts the set of deployment device states returned. You can filter on
        /// deviceId and moduleId and/or deviceState.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceStatesForDeviceClassSubgroupDeploymentsAsync(string,string,string,string,CancellationToken)']/*" />
        public virtual AsyncPageable<DeploymentDeviceState> GetDeviceStatesForDeviceClassSubgroupDeploymentsAsync(string groupId, string deviceClassId, string deploymentId, string filter = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsRequest(groupId, deviceClassId, deploymentId, filter, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsNextPageRequest(nextLink, groupId, deviceClassId, deploymentId, filter, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, DeploymentDeviceState.DeserializeDeploymentDeviceState, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDeviceStatesForDeviceClassSubgroupDeployments", "value", "nextLink", context);
        }

        /// <summary>
        /// Gets a list of devices in a deployment along with their state. Useful for
        /// getting a list of failed devices.
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="filter">
        /// Restricts the set of deployment device states returned. You can filter on
        /// deviceId and moduleId and/or deviceState.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceStatesForDeviceClassSubgroupDeployments(string,string,string,string,CancellationToken)']/*" />
        public virtual Pageable<DeploymentDeviceState> GetDeviceStatesForDeviceClassSubgroupDeployments(string groupId, string deviceClassId, string deploymentId, string filter = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsRequest(groupId, deviceClassId, deploymentId, filter, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsNextPageRequest(nextLink, groupId, deviceClassId, deploymentId, filter, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, DeploymentDeviceState.DeserializeDeploymentDeviceState, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDeviceStatesForDeviceClassSubgroupDeployments", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Gets a list of devices in a deployment along with their state. Useful for
        /// getting a list of failed devices.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeviceStatesForDeviceClassSubgroupDeploymentsAsync(string,string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="filter">
        /// Restricts the set of deployment device states returned. You can filter on
        /// deviceId and moduleId and/or deviceState.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceStatesForDeviceClassSubgroupDeploymentsAsync(string,string,string,string,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetDeviceStatesForDeviceClassSubgroupDeploymentsAsync(string groupId, string deviceClassId, string deploymentId, string filter, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsRequest(groupId, deviceClassId, deploymentId, filter, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsNextPageRequest(nextLink, groupId, deviceClassId, deploymentId, filter, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDeviceStatesForDeviceClassSubgroupDeployments", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Gets a list of devices in a deployment along with their state. Useful for
        /// getting a list of failed devices.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDeviceStatesForDeviceClassSubgroupDeployments(string,string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="groupId">
        /// Group identity. This is created from the value of the ADUGroup tag in the Iot
        /// Hub's device/module twin or $default for devices with no tag.
        /// </param>
        /// <param name="deviceClassId">
        /// Device class subgroup identity. This is generated from the model Id and the
        /// compat properties reported by the device update agent in the Device Update PnP
        /// interface in IoT Hub. It is a hex-encoded SHA1 hash.
        /// </param>
        /// <param name="deploymentId">
        /// The caller-provided deployment identifier. This cannot be longer than 73
        /// characters, must be all lower-case, and cannot contain '&amp;', '^', '[', ']', '{',
        /// '}', '|', '&lt;', '&gt;', forward slash, backslash, or double quote. The Updates view
        /// in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you
        /// create a deployment.
        /// </param>
        /// <param name="filter">
        /// Restricts the set of deployment device states returned. You can filter on
        /// deviceId and moduleId and/or deviceState.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetDeviceStatesForDeviceClassSubgroupDeployments(string,string,string,string,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetDeviceStatesForDeviceClassSubgroupDeployments(string groupId, string deviceClassId, string deploymentId, string filter, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsRequest(groupId, deviceClassId, deploymentId, filter, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsNextPageRequest(nextLink, groupId, deviceClassId, deploymentId, filter, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetDeviceStatesForDeviceClassSubgroupDeployments", "value", "nextLink", context);
        }

        /// <summary> Get a list of all device import operations. Completed operations are kept for 7 days before auto-deleted. </summary>
        /// <param name="filter"> Restricts the set of operations returned. Only one specific filter is supported: \"status eq 'NotStarted' or status eq 'Running'\". </param>
        /// <param name="maxCount">
        /// Specifies a non-negative integer n that limits the number of items returned
        /// from a collection. The service returns the number of available items up to but
        /// not greater than the specified value n.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetOperationStatusesAsync(string,int?,CancellationToken)']/*" />
        public virtual AsyncPageable<DeviceOperation> GetOperationStatusesAsync(string filter = null, int? maxCount = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetOperationStatusesRequest(filter, maxCount, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetOperationStatusesNextPageRequest(nextLink, filter, maxCount, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, DeviceOperation.DeserializeDeviceOperation, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetOperationStatuses", "value", "nextLink", context);
        }

        /// <summary> Get a list of all device import operations. Completed operations are kept for 7 days before auto-deleted. </summary>
        /// <param name="filter"> Restricts the set of operations returned. Only one specific filter is supported: \"status eq 'NotStarted' or status eq 'Running'\". </param>
        /// <param name="maxCount">
        /// Specifies a non-negative integer n that limits the number of items returned
        /// from a collection. The service returns the number of available items up to but
        /// not greater than the specified value n.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetOperationStatuses(string,int?,CancellationToken)']/*" />
        public virtual Pageable<DeviceOperation> GetOperationStatuses(string filter = null, int? maxCount = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetOperationStatusesRequest(filter, maxCount, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetOperationStatusesNextPageRequest(nextLink, filter, maxCount, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, DeviceOperation.DeserializeDeviceOperation, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetOperationStatuses", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Get a list of all device import operations. Completed operations are kept for 7 days before auto-deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetOperationStatusesAsync(string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="filter"> Restricts the set of operations returned. Only one specific filter is supported: \"status eq 'NotStarted' or status eq 'Running'\". </param>
        /// <param name="maxCount">
        /// Specifies a non-negative integer n that limits the number of items returned
        /// from a collection. The service returns the number of available items up to but
        /// not greater than the specified value n.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetOperationStatusesAsync(string,int?,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetOperationStatusesAsync(string filter, int? maxCount, RequestContext context)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetOperationStatusesRequest(filter, maxCount, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetOperationStatusesNextPageRequest(nextLink, filter, maxCount, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetOperationStatuses", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Get a list of all device import operations. Completed operations are kept for 7 days before auto-deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetOperationStatuses(string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="filter"> Restricts the set of operations returned. Only one specific filter is supported: \"status eq 'NotStarted' or status eq 'Running'\". </param>
        /// <param name="maxCount">
        /// Specifies a non-negative integer n that limits the number of items returned
        /// from a collection. The service returns the number of available items up to but
        /// not greater than the specified value n.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetOperationStatuses(string,int?,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetOperationStatuses(string filter, int? maxCount, RequestContext context)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetOperationStatusesRequest(filter, maxCount, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetOperationStatusesNextPageRequest(nextLink, filter, maxCount, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetOperationStatuses", "value", "nextLink", context);
        }

        /// <summary> Get all device diagnostics log collections. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetLogCollectionsAsync(CancellationToken)']/*" />
        public virtual AsyncPageable<LogCollection> GetLogCollectionsAsync(CancellationToken cancellationToken = default)
        {
            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetLogCollectionsRequest(context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetLogCollectionsNextPageRequest(nextLink, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, LogCollection.DeserializeLogCollection, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetLogCollections", "value", "nextLink", context);
        }

        /// <summary> Get all device diagnostics log collections. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetLogCollections(CancellationToken)']/*" />
        public virtual Pageable<LogCollection> GetLogCollections(CancellationToken cancellationToken = default)
        {
            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetLogCollectionsRequest(context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetLogCollectionsNextPageRequest(nextLink, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, LogCollection.DeserializeLogCollection, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetLogCollections", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Get all device diagnostics log collections
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLogCollectionsAsync(CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetLogCollectionsAsync(RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetLogCollectionsAsync(RequestContext context)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetLogCollectionsRequest(context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetLogCollectionsNextPageRequest(nextLink, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetLogCollections", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Get all device diagnostics log collections
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLogCollections(CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetLogCollections(RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetLogCollections(RequestContext context)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetLogCollectionsRequest(context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetLogCollectionsNextPageRequest(nextLink, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetLogCollections", "value", "nextLink", context);
        }

        /// <summary> Get list of device health. </summary>
        /// <param name="filter">
        /// Restricts the set of devices for which device health is returned. You can
        /// filter on status, device id and module id.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetHealthOfDevicesAsync(string,CancellationToken)']/*" />
        public virtual AsyncPageable<DeviceHealth> GetHealthOfDevicesAsync(string filter = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetHealthOfDevicesRequest(filter, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetHealthOfDevicesNextPageRequest(nextLink, filter, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, DeviceHealth.DeserializeDeviceHealth, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetHealthOfDevices", "value", "nextLink", context);
        }

        /// <summary> Get list of device health. </summary>
        /// <param name="filter">
        /// Restricts the set of devices for which device health is returned. You can
        /// filter on status, device id and module id.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetHealthOfDevices(string,CancellationToken)']/*" />
        public virtual Pageable<DeviceHealth> GetHealthOfDevices(string filter = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetHealthOfDevicesRequest(filter, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetHealthOfDevicesNextPageRequest(nextLink, filter, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, DeviceHealth.DeserializeDeviceHealth, ClientDiagnostics, _pipeline, "DeviceManagementClient.GetHealthOfDevices", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Get list of device health
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetHealthOfDevicesAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="filter">
        /// Restricts the set of devices for which device health is returned. You can
        /// filter on status, device id and module id.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetHealthOfDevicesAsync(string,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetHealthOfDevicesAsync(string filter, RequestContext context)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetHealthOfDevicesRequest(filter, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetHealthOfDevicesNextPageRequest(nextLink, filter, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetHealthOfDevices", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Get list of device health
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetHealthOfDevices(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="filter">
        /// Restricts the set of devices for which device health is returned. You can
        /// filter on status, device id and module id.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='GetHealthOfDevices(string,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetHealthOfDevices(string filter, RequestContext context)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetHealthOfDevicesRequest(filter, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetHealthOfDevicesNextPageRequest(nextLink, filter, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "DeviceManagementClient.GetHealthOfDevices", "value", "nextLink", context);
        }

        /// <summary>
        /// Import existing devices from IoT Hub. This is a long-running-operation; use
        /// Operation-Location response header value to check for operation status.
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="importType"> The types of devices to import. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='ImportDevicesAsync(WaitUntil,ImportType,CancellationToken)']/*" />
        public virtual async Task<Operation<DeviceOperation>> ImportDevicesAsync(WaitUntil waitUntil, ImportType importType, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = BinaryData.FromObjectAsJson(importType.ToString());
            Operation<BinaryData> response = await ImportDevicesAsync(waitUntil, content, context).ConfigureAwait(false);
            return ProtocolOperationHelpers.Convert(response, DeviceOperation.FromResponse, ClientDiagnostics, "DeviceManagementClient.ImportDevices");
        }

        /// <summary>
        /// Import existing devices from IoT Hub. This is a long-running-operation; use
        /// Operation-Location response header value to check for operation status.
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="importType"> The types of devices to import. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='ImportDevices(WaitUntil,ImportType,CancellationToken)']/*" />
        public virtual Operation<DeviceOperation> ImportDevices(WaitUntil waitUntil, ImportType importType, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = BinaryData.FromObjectAsJson(importType.ToString());
            Operation<BinaryData> response = ImportDevices(waitUntil, content, context);
            return ProtocolOperationHelpers.Convert(response, DeviceOperation.FromResponse, ClientDiagnostics, "DeviceManagementClient.ImportDevices");
        }

        /// <summary>
        /// [Protocol Method] Import existing devices from IoT Hub. This is a long-running-operation; use
        /// Operation-Location response header value to check for operation status.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ImportDevicesAsync(WaitUntil,ImportType,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='ImportDevicesAsync(WaitUntil,RequestContent,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> ImportDevicesAsync(WaitUntil waitUntil, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.ImportDevices");
            scope.Start();
            try
            {
                using HttpMessage message = CreateImportDevicesRequest(content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "DeviceManagementClient.ImportDevices", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Import existing devices from IoT Hub. This is a long-running-operation; use
        /// Operation-Location response header value to check for operation status.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ImportDevices(WaitUntil,ImportType,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/DeviceManagementClient.xml" path="doc/members/member[@name='ImportDevices(WaitUntil,RequestContent,RequestContext)']/*" />
        public virtual Operation<BinaryData> ImportDevices(WaitUntil waitUntil, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.ImportDevices");
            scope.Start();
            try
            {
                using HttpMessage message = CreateImportDevicesRequest(content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "DeviceManagementClient.ImportDevices", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetDeviceClassesRequest(string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/deviceClasses", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassRequest(string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/deviceClasses/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateDeviceClassRequest(string deviceClassId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/deviceClasses/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/merge-patch+json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteDeviceClassRequest(string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/deviceClasses/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetInstallableUpdatesForDeviceClassesRequest(string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/deviceClasses/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/installableUpdates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDevicesRequest(string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/devices", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateImportDevicesRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/devices:import", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDeviceRequest(string deviceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/devices/", false);
            uri.AppendPath(deviceId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceModuleRequest(string deviceId, string moduleId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/devices/", false);
            uri.AppendPath(deviceId, true);
            uri.AppendPath("/modules/", false);
            uri.AppendPath(moduleId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetUpdateComplianceRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/updateCompliance", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetGroupsRequest(string orderby, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (orderby != null)
            {
                uri.AppendQuery("orderby", orderby, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetGroupRequest(string groupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteGroupRequest(string groupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetUpdateComplianceForGroupRequest(string groupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/updateCompliance", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetBestUpdatesForGroupsRequest(string groupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/bestUpdates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsForGroupsRequest(string groupId, string orderby, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deployments", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (orderby != null)
            {
                uri.AppendQuery("orderby", orderby, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentRequest(string groupId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateOrUpdateDeploymentRequest(string groupId, string deploymentId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200201);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteDeploymentRequest(string groupId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentStatusRequest(string groupId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendPath("/status", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassSubgroupsForGroupsRequest(string groupId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassSubgroupRequest(string groupId, string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteDeviceClassSubgroupRequest(string groupId, string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassSubgroupUpdateComplianceRequest(string groupId, string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/updateCompliance", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetBestUpdatesForDeviceClassSubgroupRequest(string groupId, string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/bestUpdates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsForDeviceClassSubgroupsRequest(string groupId, string deviceClassId, string orderby, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (orderby != null)
            {
                uri.AppendQuery("orderby", orderby, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentForDeviceClassSubgroupRequest(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteDeploymentForDeviceClassSubgroupRequest(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateStopDeploymentRequest(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendPath(":cancel", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateRetryDeploymentRequest(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendPath(":retry", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassSubgroupDeploymentStatusRequest(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendPath("/status", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsRequest(string groupId, string deviceClassId, string deploymentId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendPath("/devicestates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetOperationStatusesRequest(string filter, int? maxCount, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/operations", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            if (maxCount != null)
            {
                uri.AppendQuery("top", maxCount.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLogCollectionsRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/deviceDiagnostics/logCollections", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLogCollectionRequest(string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/deviceDiagnostics/logCollections/", false);
            uri.AppendPath(operationId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateStartLogCollectionRequest(string operationId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/deviceDiagnostics/logCollections/", false);
            uri.AppendPath(operationId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetLogCollectionDetailedStatusRequest(string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/deviceDiagnostics/logCollections/", false);
            uri.AppendPath(operationId, true);
            uri.AppendPath("/detailedStatus", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetHealthOfDevicesRequest(string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendPath("/management/deviceDiagnostics/deviceHealth", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassesNextPageRequest(string nextLink, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetInstallableUpdatesForDeviceClassesNextPageRequest(string nextLink, string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDevicesNextPageRequest(string nextLink, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetGroupsNextPageRequest(string nextLink, string orderby, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetBestUpdatesForGroupsNextPageRequest(string nextLink, string groupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsForGroupsNextPageRequest(string nextLink, string groupId, string orderby, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassSubgroupsForGroupsNextPageRequest(string nextLink, string groupId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsForDeviceClassSubgroupsNextPageRequest(string nextLink, string groupId, string deviceClassId, string orderby, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsNextPageRequest(string nextLink, string groupId, string deviceClassId, string deploymentId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetOperationStatusesNextPageRequest(string nextLink, string filter, int? maxCount, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLogCollectionsNextPageRequest(string nextLink, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetHealthOfDevicesNextPageRequest(string nextLink, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRaw("/deviceUpdate/", false);
            uri.AppendRaw(_instanceId, true);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static RequestContext DefaultRequestContext = new RequestContext();
        internal static RequestContext FromCancellationToken(CancellationToken cancellationToken = default)
        {
            if (!cancellationToken.CanBeCanceled)
            {
                return DefaultRequestContext;
            }

            return new RequestContext() { CancellationToken = cancellationToken };
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
        private static ResponseClassifier _responseClassifier202;
        private static ResponseClassifier ResponseClassifier202 => _responseClassifier202 ??= new StatusCodeClassifier(stackalloc ushort[] { 202 });
        private static ResponseClassifier _responseClassifier200201;
        private static ResponseClassifier ResponseClassifier200201 => _responseClassifier200201 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 201 });
        private static ResponseClassifier _responseClassifier201;
        private static ResponseClassifier ResponseClassifier201 => _responseClassifier201 ??= new StatusCodeClassifier(stackalloc ushort[] { 201 });
    }
}
